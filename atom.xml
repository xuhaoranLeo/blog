<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leo</title>
  
  <subtitle>侠心交友，素心做人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xuhaoranleo.top/"/>
  <updated>2018-04-18T08:45:26.127Z</updated>
  <id>http://xuhaoranleo.top/</id>
  
  <author>
    <name>许昊然</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>老年人的基础笔记-iOS</title>
    <link href="http://xuhaoranleo.top/2018/04/11/%E8%80%81%E5%B9%B4%E4%BA%BA%E7%9A%84%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-iOS/"/>
    <id>http://xuhaoranleo.top/2018/04/11/老年人的基础笔记-iOS/</id>
    <published>2018-04-11T08:21:34.000Z</published>
    <updated>2018-04-18T08:45:26.127Z</updated>
    
    <content type="html"><![CDATA[<p><em>太久没有动笔了，最近面临着换工作，需要复习一下早已忘记的基础知识了，考虑到老年人只有1周的记忆，所以2018年第一篇博客，献给我自己，方便以后随时查看补充。</em></p><a id="more"></a><h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><h3 id="什么才是好的架构"><a href="#什么才是好的架构" class="headerlink" title="什么才是好的架构"></a>什么才是好的架构</h3><ul><li>各部分职责清晰、单一、具体</li><li>具有可测性，让单元测试尽可能覆盖</li><li>使用成本低，维护成本也低</li></ul><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>两张经典的图，第一张为苹果期望中的MVC，第二张为实际项目中的MVC：</p><p><img src="/assets/ArticleImg/mvc1.png" alt="苹果期望的MVC"></p><p><img src="/assets/ArticleImg/mvc2.png" alt="现实中的MVC"></p><p>Cocoa中的MVC可以称作重控制器模式，期望中View与Model通过Controller进行间接联系，从而达到解耦，但是实际中View与Controller耦合非常严重，Controller异常庞大，可测试性与Debug效率很低。但是相比其他模式，代码总量偏少，门槛低，便于简单的项目进行快速开发。</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>这是一张关于MVP的经典图：</p><p><img src="/assets/ArticleImg/mvp.png" alt="mvp"></p><p>与MVC看似相似，实际上有很大不同，View层实际上是View也是Controller，Presenter层用来负责将Model与View/Controller进行组合，并且不会存在具体的布局，只有数据组装。一般来讲，逻辑部分的处理都在Model与Presenter层，这就造就了一个轻量级的View层，便于进行单元测试，虽然代码量多了很多很多，但是设计逻辑并不会比MVC复杂多少。</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>还是先放经典图：</p><p><img src="/assets/ArticleImg/mvvm.png" alt="mvvm"></p><p>与MVP的结构看起来很像，Presenter换成了ViewModel而已。其实，ViewModel并不是直接把二者的数据组合到一起，View层负责绑定ViewModel并传递所有的事件消息，ViewModel响应这些消息进而更新数据并进行页面展示。简单来讲，ViewModel连接View与Model，其中一者发送消息，另一方及时改变。</p><p>MVVM的绑定与消息机制可以通过KVO或者消息通知等方式实现，或者可以用到更强大的ReactiveCocoa这种响应式框架，但同时也将面临着复杂的调试环境。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>一种架构并不是一个项目中唯一存在，而是根据项目规模、业务场景以及各种因素决定的，MV(X)架构模式都是彼此兼容，可以任意组合和转换的。</p><h2 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h2><h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><p>在<code>objc.h</code>中可以看到类是由<code>Class</code>表示的，实质上是一个指向<code>objc_class</code>结构体的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure><p>而在<code>runtime.h</code>中的 <code>objc_class</code>结构体的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> * _<span class="title">Nullable</span> <span class="title">ivars</span>                  <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> * _<span class="title">Nullable</span> * _<span class="title">Nullable</span> <span class="title">methodLists</span>                    <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> * _<span class="title">Nonnull</span> <span class="title">cache</span>                       <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> * _<span class="title">Nullable</span> <span class="title">protocols</span>          <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><ul><li>isa指针指向的是也是一个类，类对象的isa指向的是这个类的所属类，也就是元类(metaclass)。日常使用的类方法就是保存在元类的类方法列表中，使用时通过isa去元类中的类方法列表寻找对应的函数指针。</li><li>ivars成员变量列表，保存着这个类下面的所有实例变量的地址指针。</li><li>info标识符，其中<code>CLS_CLASS(0x1)</code>表示该类为普通类，而<code>CLS_META(0x2)</code>表示该类为元类，还有其他将近20个标识，具体可以查看<code>runtime.h</code>源码。</li><li>methodLists方法列表，根据info标识符，普通类保存的就是实例方法，元类保存的就是类方法。</li><li>cache缓存方法列表，在调用方法的时候，系统会先遍历缓存中是否使用过该方法，没有的话再去方法列表调用。</li></ul><h3 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h3><p>对类对象使用<code>new/alloc</code>操作后会创建该类的实例对象，本质使用<code>class_createInstance</code>方法创建一个指向<code>objc_object</code>结构体的指针，在<code>objc.h</code>中定义为：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an<span class="built_in"> instance </span>of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAI<span class="class">LABILITY;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个实例的类型都是它的类对象，而<code>id</code>也是一个实例对象的类型，这个类型可以转换成任何一种实例对象，在<code>objc.h</code>中的定义：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// A pointer to an<span class="built_in"> instance </span>of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure><h3 id="元类对象"><a href="#元类对象" class="headerlink" title="元类对象"></a>元类对象</h3><p>元类是类对象的类，类对象的isa指针指向的就是元类，它的isa指针指向的是它父类的地址，其中存储着类对象的类方法列表。<code>runtime.h</code>中提供了一些元类的方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">OBJC_EXPORT</span> <span class="selector-tag">Class</span> _<span class="selector-tag">Nullable</span></span><br><span class="line"><span class="selector-tag">objc_getMetaClass</span>(<span class="selector-tag">const</span> <span class="selector-tag">char</span> * _<span class="selector-tag">Nonnull</span> <span class="selector-tag">name</span>)</span><br><span class="line">    <span class="selector-tag">OBJC_AVAILABLE</span>(10<span class="selector-class">.0</span>, 2<span class="selector-class">.0</span>, 9<span class="selector-class">.0</span>, 1<span class="selector-class">.0</span>, 2<span class="selector-class">.0</span>);</span><br><span class="line"><span class="selector-tag">OBJC_EXPORT</span> <span class="selector-tag">BOOL</span></span><br><span class="line"><span class="selector-tag">class_isMetaClass</span>(<span class="selector-tag">Class</span> _<span class="selector-tag">Nullable</span> <span class="selector-tag">cls</span>) </span><br><span class="line">    <span class="selector-tag">OBJC_AVAILABLE</span>(10<span class="selector-class">.5</span>, 2<span class="selector-class">.0</span>, 9<span class="selector-class">.0</span>, 1<span class="selector-class">.0</span>, 2<span class="selector-class">.0</span>);</span><br></pre></td></tr></table></figure><h3 id="实例、类、元类的关系"><a href="#实例、类、元类的关系" class="headerlink" title="实例、类、元类的关系"></a>实例、类、元类的关系</h3><p>从网上找的很经典的两张图：</p><p><img src="/assets/ArticleImg/instance、class、metaclass1.png" alt="instance、class、metaclass1"></p><p><img src="/assets/ArticleImg/instance、class、metaclass2.jpg" alt="instance、class、metaclass2"></p><p>通过这两张图能很明显地看出三者之间的横向、纵向以及内部的关系，不再赘述。</p><h2 id="KVC与KVO"><a href="#KVC与KVO" class="headerlink" title="KVC与KVO"></a>KVC与KVO</h2><h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><p>键值编码，使用<code>valueForKey:</code>来获取值，使用<code>setValue:forKey:</code>来赋值，利用字符串作为Key去查找和修改相应的Value，流程大致如下：</p><ul><li>在对象中查找<code>set</code>方法，如果有，就给这个对象赋值。</li><li>如果没有<code>set</code>方法，则寻找<code>_key</code>成员属性，如果有就赋值。</li><li>如果没有<code>_key</code>属性，则去寻找<code>key</code>属性，如果有就赋值。</li><li>以上都不成立，报错。</li></ul><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>键值观察，日常使用三个个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加观察者</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"><span class="comment">// 移除观察者</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"><span class="comment">// 代理回调</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure><p>KVO是基于<code>runtime</code>机制实现的，内部原理如下：</p><ul><li>当某个类<code>ClassA</code>的属性被观察时，系统会动态地创建一个派生类<code>NSKVONotifying_ClassA</code>继承于它。</li><li>在派生类中重写被观察属性的<code>set</code>方法，<code>NSObject(NSKeyValueObserverNotification)</code>的两个方法帮助完成了这整个的过程：</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">setSome:</span>(id)aSome &#123;</span><br><span class="line">  [self <span class="string">willChangeValueForKey:</span>@<span class="string">"some"</span>];</span><br><span class="line">  [<span class="keyword">super</span> <span class="string">setValue:</span>aSome <span class="string">forKey:</span>@<span class="string">"some"</span>];</span><br><span class="line">  [self <span class="string">didChangeValueForKey:</span>@<span class="string">"some"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当被观察时，系统将<code>ClassA</code>的isa指针指向<code>NSKVONotifying_ClassA</code>，从而被观察属性变化时，调用的是重写后的<code>set</code>方法。</li><li>在被观察者值变化之前和之后，通过代理会掉通知观察者。</li></ul><h2 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h2><p>苹果文档上说明，不论在MRC还是ARC模式下，都应该用<code>@autoreleasepool {}</code>这个block来创建使用自动释放池。强调一下，<code>autoreleasepool</code>在ARC下依然有其重要作用！</p><p>在工程<code>main.m</code>中，系统为我们在程序的入口处就使用了一个<code>autoreleasepool</code>来包裹整个程序，每个程序中至少都要有一个<code>autoreleasepool</code>。</p><p>在MRC的环境下，自动释放池的整个过程大致为：</p><ul><li>系统每个线程中存在一个<code>NSAutoreleasePool</code>的栈，当新的<code>autoreleasepool</code>创建时入栈，被销毁时出栈。</li></ul><ul><li><code>[Object autorelease]</code>表示将对象放入一个池中，会有很多对象进入<code>autoreleasepool</code>。</li><li>当<code>autoreleasepool</code>销毁时，池子出栈，每个池中的对象执行<code>[Object release]</code>。</li></ul><h3 id="何时使用autoreleasepool"><a href="#何时使用autoreleasepool" class="headerlink" title="何时使用autoreleasepool"></a>何时使用<code>autoreleasepool</code></h3><p>苹果文档上是这么说的：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">If</span> you are writing a program that is <span class="keyword">not</span> based on a UI framework, such as a command-line tool.</span><br><span class="line">如果你写的项目不是基于UI framework，例如一个命令行工具。</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you write a loop that creates many temporary objects.</span><br><span class="line">You may use an autorelease<span class="built_in"> pool </span>block inside the loop <span class="keyword">to</span> dispose of those objects before the next iteration. Using an autorelease<span class="built_in"> pool </span>block <span class="keyword">in</span> the loop helps <span class="keyword">to</span> reduce the maximum memory footprint of the application.</span><br><span class="line">如果你写一个包含很多临时对象的循环，你可以在循环内部使用一个自动释放池，在下一次循环前来管理这些对象。这样使用可以帮助减少app的峰值内存。</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you spawn a secondary thread.</span><br><span class="line">You must create your own autorelease<span class="built_in"> pool </span>block as soon as the thread begins executing; otherwise, your application will leak objects.</span><br><span class="line">如果你创建一个辅助线程，那么当线程一开始执行时，必须创建一个自动释放池，否则你的app将会出现内存泄漏。</span><br></pre></td></tr></table></figure><p>对于iOS开发来说，不论在MRC还是ARC下，都可以用到的场景：</p><ul><li>大型的循环可以在内部使用<code>autoreleasepool</code>优化循环的资源消耗。</li><li>使用常驻的辅助线程（类似于AFNetworking线程）时必须使用<code>autoreleasepool</code>。</li></ul><p><code>SDWebImage</code>中对图片的缓存用到了<code>autoreleasepool</code>来优化资源消耗：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_async(self.ioQueue, </span>^&#123;</span><br><span class="line">if (operation.isCancelled) &#123;</span><br><span class="line">return<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">UIImage *<span class="keyword">diskImage </span>= [self <span class="keyword">diskImageForKey:key];</span></span><br><span class="line"><span class="keyword"></span>if (<span class="keyword">diskImage </span>&amp;&amp; self.<span class="keyword">shouldCacheImagesInMemory) </span>&#123;</span><br><span class="line">NSUInteger cost = SDCacheCostForImage(<span class="keyword">diskImage);</span></span><br><span class="line"><span class="keyword"></span>[self.memCache setObject:<span class="keyword">diskImage </span>forKey:key cost:cost]<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">dispatch_async(dispatch_get_main_queue(), </span>^&#123;</span><br><span class="line">doneBlock(<span class="keyword">diskImage, </span>SDImageCacheTypeDisk)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h2><p><code>RunLoop</code>是一个管理待处理事件和消息的对象，提供一个入口函数来执行事件循环的逻辑，是iOS消息机制的处理模式。每个线程都有自己的<code>RunLoop</code>来保证随时处理事件而不退出。</p><p>iOS系统中提供了两个<code>RunLoop</code>对象，一个是<code>NSRunLoop</code>，另一个是<code>CFRunLoopRef</code>。前者是基于后者的封装，提供了面向对象的API，但是这些API并未线程安全。而后者提供的是基于<code>CoreFoundation</code>框架的纯C函数API，这些API都是线程安全的。</p><h3 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h3><p><code>CFRunLoop</code>是基于<code>pthread</code>来管理的，由于苹果不允许直接创建<code>RunLoop</code>，所以只能通过两个函数来获取：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><p><code>RunLoop</code>与线程之间是一一对应的，其关系保存在一个全局的<code>Dictionary</code>中。线程创建后，如果不主动获取，那么一直不会创建自己的<code>RunLoop</code>，而线程结束时，<code>RunLoop</code>也同时销毁。除了主线程以外，只能在当前线程中才能获取其<code>RunLoop</code>。</p><h3 id="RunLoop的API"><a href="#RunLoop的API" class="headerlink" title="RunLoop的API"></a>RunLoop的API</h3><p>在<code>CFRunLoop.h</code>类中可以看到<code>RunLoop</code>大致的结构：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CFStringRef</span> <span class="built_in">CFRunLoopMode</span> <span class="built_in">CF_EXTENSIBLE_STRING_ENUM</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="keyword">id</span>) __CFRunLoop * <span class="built_in">CFRunLoopRef</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="keyword">id</span>) __CFRunLoopSource * <span class="built_in">CFRunLoopSourceRef</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="keyword">id</span>) __CFRunLoopObserver * <span class="built_in">CFRunLoopObserverRef</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="built_in">NSTimer</span>) __CFRunLoopTimer * <span class="built_in">CFRunLoopTimerRef</span>;</span><br></pre></td></tr></table></figure><p>在这张图中能看出它们之间的大致关系：</p><p><img src="/assets/ArticleImg/runloop1.png" alt="runloop1"></p><p>一个<code>RunLoop</code>中包含若干个<code>Mode</code>，每个<code>Model</code>中包含若干个<code>Source/Timer/Observer</code>。每次调用<code>RunLoop</code>时只能指定一个<code>Mode</code>，如果需要切换<code>Mode</code>，只能退出重新进入，指定一个新的。</p><ul><li>CFRunLoopRef中可以有多个<code>mode</code>。一个<code>mode</code>可以将自己的<code>_name</code>标记为<code>Common</code>属性来将其加入到<code>_commonModes</code>，每当 <code>RunLoop</code> 的内容发生变化时，都会自动将<code>_commonModeItems</code>里的 <code>Source/Observer/Timer</code>同步到具有<code>Common</code>标记的所有<code>mode</code>里。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>CFRunLoopSourceRef是事件源，分为<code>source0</code>和<code>source1</code>两种类型。其中<code>source0</code>不能主动触发事件，而<code>source1</code>中有一个<code>mach_port</code>，可以主动唤醒<code>RunLoop</code>的线程。</li><li>CFRunLoopObserverRef是观察者，每个<code>Observer</code>都包含了一个回调，当观测的状态发生变化时回调这个变化，具体变化：</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>),</span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),</span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),</span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>CFRunLoopTimerRef是触发器，包含了一个时间长度和一个回调，当其加入<code>RunLoop</code>中时会注册对应的时间点，到时<code>RunLoop</code>会被唤醒执行回调。</li></ul><p>苹果公开提供了三个<code>mode</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// CoreFoundation</span></span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="keyword">const</span> <span class="built_in">CFRunLoopMode</span> kCFRunLoopDefaultMode;</span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="keyword">const</span> <span class="built_in">CFRunLoopMode</span> kCFRunLoopCommonModes;</span><br><span class="line"><span class="comment">/// Foundation</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSRunLoopMode</span> <span class="keyword">const</span> <span class="built_in">NSDefaultRunLoopMode</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSRunLoopMode</span> <span class="keyword">const</span> <span class="built_in">NSRunLoopCommonModes</span> API_AVAILABLE(macos(<span class="number">10.5</span>), ios(<span class="number">2.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSRunLoopMode</span> <span class="keyword">const</span> <span class="built_in">UITrackingRunLoopMode</span>;</span><br></pre></td></tr></table></figure><p><code>CommonModes</code>是一个集合，<code>DefaultMode</code>和<code>Tranking Mode</code>都被标记了<code>Common</code>属性。日常使用<code>NSTimer</code>时为了防止滑动失效，需要将<code>timer</code>加入到<code>RunLoop</code>并设置模式为<code>NSRunLoopCommonModes</code>。</p><h3 id="RunLoop内部逻辑"><a href="#RunLoop内部逻辑" class="headerlink" title="RunLoop内部逻辑"></a>RunLoop内部逻辑</h3><p><img src="/assets/ArticleImg/runloop2.png" alt="runloop2"></p><p><code>RunLoop</code>本身其实就是一个<code>do-while</code>的循环，当调用的时候会一直停留在这个循环里，直到超时或者手动停止。其核心是基于<code>mach_port</code>的，<code>source0</code>是在<code>RunLoop</code>开始的时候触发的，当它的回调处理结束之后，如果存在<code>source1</code>则进去等待状态，调用<code>mach_msg()</code>方法等待接收通过<code>mach_port</code>发来的消息，如果等待超时或者接收到消息则处理并执行下一条。</p><h4 id="与GCD"><a href="#与GCD" class="headerlink" title="与GCD"></a>与GCD</h4><p>在<code>RunLoop</code>中大量用到了GCD，而GCD中也有用到<code>RunLoop</code>的地方。<code>RunLoop</code>的超时时间使用的是GCD的<code>dispatch_source_t</code>定时器实现的。同时GCD中的<code>dispatch_async()</code>也用到了<code>RunLoop</code>，这个仅仅限于在主线程中的使用<code>dispatch_get_main_queue()</code>。</p><h4 id="与Autoreleasepool"><a href="#与Autoreleasepool" class="headerlink" title="与Autoreleasepool"></a>与Autoreleasepool</h4><p>苹果在App启动后，在主线程的<code>RunLoop</code>中注册了两个<code>CFRunLoopObserver</code>，它们的回调均是<code>_wrapRunLoopWithAutoreleasePoolHandler</code>。</p><p>第一个<code>Observer</code>用来监视Entry事件，它的回调会调用<code>_objc_autoreleasePoolPush()</code>创建自动释放池并入栈，其序列优先级非常非常高，保证其创建的释放池发生在所有回调之前。</p><p>第二个<code>Observer</code>监视BeforeWaiting和Exit事件。当BeforeWaiting时，调用<code>_objc_autoreleasePoolPop()</code>和<code>_objc_autoreleasePoolPush()</code>，释放旧的池出栈并创建新的池入栈等待；当Exit时，直接调用<code>_objc_autoreleasePoolPop()</code>来释放池子。这个序列优先级非常非常低，保证其释放池子的行为发生在所有回调之后。</p><p>在主线程执行的代码，通常写在事件回调、计时器回调内的这些会被<code>RunLoop</code>创建好的释放池围绕着，所以不会出现内存泄漏。而子线程需要手动的调用<code>run()</code>方法来让<code>RunLoop</code>跑起来并创建释放池。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h2 id="计时器相关"><a href="#计时器相关" class="headerlink" title="计时器相关"></a>计时器相关</h2><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><h2 id="事件响应与传递"><a href="#事件响应与传递" class="headerlink" title="事件响应与传递"></a>事件响应与传递</h2><h2 id="图片解压缩"><a href="#图片解压缩" class="headerlink" title="图片解压缩"></a>图片解压缩</h2><h2 id="UITableView优化"><a href="#UITableView优化" class="headerlink" title="UITableView优化"></a>UITableView优化</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/b849c6972216" target="_blank" rel="noopener">iOS 的架构模式</a></p><p><a href="https://www.jianshu.com/p/0ba0b2bac78a" target="_blank" rel="noopener">格物致知iOS类与对象</a></p><p><a href="https://www.jianshu.com/p/829864680648" target="_blank" rel="noopener">探究KVO的底层实现原理</a></p><p><a href="https://www.jianshu.com/p/5559bc15490d" target="_blank" rel="noopener">iOS中autorelease的那些事儿</a></p><p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;太久没有动笔了，最近面临着换工作，需要复习一下早已忘记的基础知识了，考虑到老年人只有1周的记忆，所以2018年第一篇博客，献给我自己，方便以后随时查看补充。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://xuhaoranleo.top/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>小小少年</title>
    <link href="http://xuhaoranleo.top/2018/04/10/%E5%B0%8F%E5%B0%8F%E5%B0%91%E5%B9%B4/"/>
    <id>http://xuhaoranleo.top/2018/04/10/小小少年/</id>
    <published>2018-04-10T08:42:22.000Z</published>
    <updated>2018-04-18T08:45:26.127Z</updated>
    
    <content type="html"><![CDATA[<p><em>此时此景，感慨万千啊，少年不知愁滋味，再也回不去了。</em></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=395479&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;此时此景，感慨万千啊，少年不知愁滋味，再也回不去了。&lt;/em&gt;&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://xuhaoranleo.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo的博客搭建 for Mac</title>
    <link href="http://xuhaoranleo.top/2017/11/27/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://xuhaoranleo.top/2017/11/27/基于Hexo的博客搭建/</id>
    <published>2017-11-27T08:42:22.000Z</published>
    <updated>2018-04-18T08:45:26.127Z</updated>
    
    <content type="html"><![CDATA[<p><em>这是迁移博客后的第二篇，其实我很懒，并不喜欢写博客这种吃力不讨好的活儿，看的人也未必多，但是每次写完一篇博客之后的<del>短暂的</del>成就感以及写的这个过程中这种强制性的学习过程是很令人受用的。</em></p><p><em>既然觉得在这个博客写下去，那么就总要找点内容，这次就来写一下这个小博客的搭建过程吧，其中绝大多数都是参照的网上资料，写这篇就当做是整理归纳成自己的东西吧。</em></p><a id="more"></a><h2 id="关于Hexo"><a href="#关于Hexo" class="headerlink" title="关于Hexo"></a>关于Hexo</h2><p>我先后用过博客园、简书、<code>GithubPage</code>+<code>Hexo</code>三个博客，从一个迁移到另一个根本原因就是好不好看，Hexo提供了众多丰富的主题，这点是最打动我的。至于什么是<code>Hexo</code>？套用官网的话来说：</p><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p><code>Hexo</code>没有编辑器，也没有可视化的操作页面，在配置好必要的环境之后，书写文章要依赖其他的<code>Markdown</code>编辑器，而且关键是相对于简书这种平台类博客，缺少了推广的重要渠道，写博客自然是想让更多的人们看到，而自建博客<del>（如我的博客）</del>需要你去研究SEO…如果这么多缺点还没打消你看下去的想法，那么恭喜你将会有一个有（neng）个（zhuang）性（bi）的博客。</p><h2 id="环境配置及安装"><a href="#环境配置及安装" class="headerlink" title="环境配置及安装"></a>环境配置及安装</h2><ol><li><p>Node.js</p><p>  移步<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网</a>进行安装。</p></li><li><p>Git</p><p>  Xcode自带Git环境，或者移步<a href="https://git-scm.com" target="_blank" rel="noopener">Git官网</a>进行安装，再或者使用<code>Homebrew</code>安装：</p>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span><span class="keyword">install </span>git</span><br></pre></td></tr></table></figure></li></ol><hr><p>当安装完<code>Node.js</code>和<code>Git</code>之后，就可以进行<code>Hexo</code>安装了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><p>安装成功之后可以<code>cd</code>到你想要存放博客的目录，默认为<code>~/</code>目录，执行建站命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init BlogName</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line">// 成功之后的目录结构如下</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>命令执行结束后，就可以正式使用<code>Hexo</code>了，使用<code>debug</code>模式进行查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo s --debug</span></span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:4000</code>就可以看到<code>Hexo</code>的默认界面了。</p><h2 id="托管博客"><a href="#托管博客" class="headerlink" title="托管博客"></a>托管博客</h2><p>在本地<code>Hexo</code>搭建好之后就要选择服务器进行托管，这里只讲一下通过<code>Github</code>进行托管的方法。关于自有VPS的托管可以参考<a href="http://www.swiftyper.com/2016/04/17/deploy-hexo-with-git-hook/" target="_blank" rel="noopener">这篇文章</a>。</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>进入<code>Github</code>新建仓库，名称格式为<code>UserName.github.io</code>，例如<code>xuhaoranLeo.github.io</code>。然后将本地<code>Hexo</code>的<code>站点配置文件</code>的配置仓库修改为当前仓库的<code>git</code>地址：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~<span class="meta-keyword">/blog/</span></span><br><span class="line">$ open _config.yml</span><br><span class="line"><span class="comment">// 修改repository</span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repository:</span> https:<span class="comment">//github.com/xuhaoranLeo/xuhaoranleo.github.com.git</span></span><br><span class="line"><span class="symbol">branch:</span> master</span><br></pre></td></tr></table></figure><p>此处注意<code>:</code>后面要接<code>Space</code>，这种格式才能被<code>Hexo</code>识别。</p><h3 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h3><p>仓库配置好之后，要为你的<code>Github</code>添加<code>ssh public key</code>。</p><blockquote><p>SSH 密钥对可以让您方便的登录到 SSH 服务器，而无需输入密码。由于您无需发送您的密码到网络中，SSH 密钥对被认为是更加安全的方式。</p><p>SSH 密钥对总是成双出现的，一把公钥，一把私钥。公钥可以自由的放在您所需要连接的 SSH 服务器上，而私钥必须稳妥的保管好。</p><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录 shell，不再要求密码。这样子，我们即可保证了整个登录过程的安全，也不会受到中间人攻击。</p><p>—— archlinux page</p></blockquote><p>理解完<code>ssh key</code>之后就可以进行生成了：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span><br><span class="line">Enter file in which to save the key (/Users/xuhaoran/.ssh/id_rsa): // 输入绝对地址和名称，直接enter使用默认</span><br><span class="line">Enter passphrase (empty for no passphrase):  // 输入ssh key的密码，直接enter是不使用密码</span><br><span class="line"></span><br><span class="line">// 生成成功</span><br><span class="line">The key's randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|<span class="string">    ..o .    ..+ </span>|</span><br><span class="line">|<span class="string">     oo. .    o.o</span>|</span><br><span class="line">|<span class="string">     +  o .  o +B</span>|</span><br><span class="line">|<span class="string">      o+ +. + =.%</span>|</span><br><span class="line">|<span class="string">       +S.++ + B+</span>|</span><br><span class="line">|<span class="string">      ..+O= E   *</span>|</span><br><span class="line">|<span class="string">         +.o   .o</span>|</span><br><span class="line">|<span class="string">        .      . </span>|</span><br><span class="line">|<span class="string">                 </span>|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><p>成功生成之后使用任意方法打开<code>.public</code>文件，复制里面的密钥，粘贴到<code>Github -&gt; Settings -&gt; SSH and GPG keys -&gt; New SSH key -&gt;Key</code>中，<code>Title</code>可以随意写。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>安装完<code>Hexo</code>就可以进行日常使用了，在<code>blog</code>目录下新建文章：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="type"></span>"This is a <span class="keyword">new</span> <span class="type">article</span>"</span><br></pre></td></tr></table></figure><p><code>Hexo</code>会自动生成<code>.md</code>文件在<code>~/BlogName/source/_posts</code>目录下，可以使用各种<code>Markdown</code>编辑器进行博客的书写了。</p><p>在每篇文章里面可以配置<code>Front-matter</code>，来标记类别、时间、标签等：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Terminal命令小结</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-11</span><span class="bullet">-22</span> <span class="number">13</span><span class="string">:56:34</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Terminal</span> <span class="string">Command</span> <span class="string">Line</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>书写完成之后生成<code>generate</code>静态文件后进行部署<code>deploy</code>操作，会让你的文章发到<code>Github</code>托管的服务器上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo g -d</span></span><br></pre></td></tr></table></figure><p>日常书写之外，如果你还想定制多样化的博客样式，可以使用各种<code>Theme</code>，<code>Hexo</code>默认的样式为<code>landscape</code>，我的博客的样式为<code>NexT</code>。其他各种样式可以去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网主题搜索</a>。</p><p>例如找到<code>NexT</code>主题后进入其<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Github</a>，使用<code>git</code>进行安装：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure><p>之后修改<code>站点配置文件</code>中的<code>theme</code>属性：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: <span class="keyword">next</span></span><br></pre></td></tr></table></figure><p>最后清空缓存并重新生成部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g -d</span></span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在了解<code>Hexo</code>基本的部署和使用方法之后，就要进行一些站点和主题的配置了，这会让你的博客更具个人色彩。</p><h3 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h3><p><code>blog</code>根目录下的<code>_config.yml</code>文件就是<code>站点配置文件</code>，可以使用编辑器打开：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">title:</span> Leo</span><br><span class="line"><span class="symbol">subtitle:</span> 侠心交友，素心做人。</span><br><span class="line"><span class="symbol">description:</span> 站在更高的地方，看见更广的世界。</span><br><span class="line"><span class="symbol">author:</span> 许昊然</span><br><span class="line"><span class="symbol">language:</span> <span class="built_in">zh</span>-Hans</span><br></pre></td></tr></table></figure><p>关于<code>title</code>、<code>description</code>等属性的具体表现形式是根据你使用的<code>Theme</code>而言的，<code>language</code>属性匹配的是<code>./themes/CurrentTheme/languages</code>下面的文件名，<code>NexT</code>下对应的简体中文就是<code>zh-Hans</code>，里面的内容之后再讲。</p><p>如果你的博客是在一个子目录下，可以设置<code>root</code>属性：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">url:</span> <span class="string">http:</span><span class="comment">//xuhaoranleo.top</span></span><br><span class="line"><span class="string">root:</span> /myBlog</span><br></pre></td></tr></table></figure><p>其他的一些属性都有相关注释解释。</p><h3 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h3><p>在<code>./themes/CurrentTheme</code>目录下的<code>_config.yml</code>文件即是<code>主题配置文件</code>，每个主题都有自己对应的属性来配置，这里只拿<code>NexT</code>这个主题简单来说：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">override:</span> false <span class="comment">// 可以用来覆盖掉站点配置文件</span></span><br><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> / || home</span><br><span class="line"><span class="symbol">  jottings:</span> <span class="meta-keyword">/tags/</span>随笔 || calendar</span><br><span class="line"><span class="symbol">  tags:</span> <span class="meta-keyword">/tags/</span> || tags</span><br><span class="line"><span class="symbol">  archives:</span> <span class="meta-keyword">/archives/</span> || archive</span><br><span class="line"><span class="symbol">menu_icons:</span></span><br><span class="line"><span class="symbol">  enable:</span> true</span><br></pre></td></tr></table></figure><p><code>menu</code>是主要需要配置的，这个就是你的博客展现出来的分类，<code>/</code>表示根目录，<code>||</code>后面接的是<code>icon name</code>，如我的博客有一个随笔分类，我是利用标签<code>tags</code>来配置的，<code>/tags/随笔</code>表示了点击的链接<code>随笔</code>标签。在随笔文章中的<code>Front-matter</code>里面配置：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tags:</span> </span><br><span class="line">- 随笔</span><br></pre></td></tr></table></figure><p>而具体是使用<code>tags</code>还是其他分类<code>archives</code>、<code>categories</code>，再或者是其他自定义的类别，主要还是根据每个类别的<code>layout</code>决定的，这个布局文件在<code>./themes/CurrentTheme/layout</code>，例如<code>tag.swig</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">social</span>:</span><br><span class="line">  <span class="attribute">GitHub</span>: <span class="attribute">https</span>:<span class="comment">//github.com/xuhaoranLeo || github</span></span><br><span class="line">  # <span class="attribute">E-Mail</span>: <span class="attribute">mailto</span>:liang_andy<span class="variable">@163</span>.com || envelope</span><br><span class="line">  微博: <span class="attribute">https</span>:<span class="comment">//weibo.com/5711479827 || weibo</span></span><br><span class="line"><span class="attribute">links</span>:</span><br><span class="line">  我的简书: <span class="attribute">http</span>:<span class="comment">//www.jianshu.com/u/8f0c4d84e87c</span></span><br></pre></td></tr></table></figure><p><code>social</code>用来配置关于你的一些其他链接的，同样<code>||</code>后面是<code>icon name</code> ；<code>links</code>则是一些友情链接，除了关联一些你喜欢的网址，据说可以在SEO中发挥一些作用，这点我并未深入了解。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">reward_comment:</span> 请我喝一杯咖啡？</span><br><span class="line"><span class="symbol">wechatpay:</span> <span class="meta-keyword">/assets/</span>blogImg/wechatpay.jpg</span><br><span class="line"><span class="meta"># alipay: /assets/blogImg/alipay.jpg</span></span><br><span class="line"><span class="meta">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure><p><code>reward</code>属性是用来接受赞助的，这没什么好讲的，主要是利用这块说一下<code>Hexo</code>里面图片的摆放，正常来说<code>Hexo</code>的博客资源都是基于<code>source</code>这个目录作为根目录的，你可以把图片全部摆在一个目录中，例如<code>assets</code>，也可以在其下具体建立新的目录进行分类，如用的时候直接用<code>Markdown</code>导入就好：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">this is a image</span>](<span class="link">/assets/blogImg/avatar.jpg</span>)</span><br></pre></td></tr></table></figure><p>其他的关于百度分析等第三方服务的接入可以自行参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT文档</a>来学习。</p><h3 id="语言配置文件"><a href="#语言配置文件" class="headerlink" title="语言配置文件"></a>语言配置文件</h3><p><code>语言配置文件</code>主要是用来显示博客整体的文字效果的，目录为<code>./themes/CurrentTheme/languages</code>，例如在<code>主题配置文件</code>中我添加了<code>jottings</code>这个新的menu，那么我就要在<code>语言配置文件</code>，对应其展现的文字：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> 首页</span><br><span class="line"><span class="symbol">  archives:</span> 归档</span><br><span class="line"><span class="symbol">  tags:</span> 标签</span><br><span class="line"><span class="symbol">  about:</span> 关于</span><br><span class="line"><span class="symbol">  jottings:</span> 随笔</span><br></pre></td></tr></table></figure><p>一些诸如<code>reward</code>你是想叫做<code>打赏</code>还是<code>乞讨</code>都可以在此处设置。</p><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><h4 id="Hexo置顶问题"><a href="#Hexo置顶问题" class="headerlink" title="Hexo置顶问题"></a>Hexo置顶问题</h4><p>参考<a href="http://www.netcan666.com/2015/11/22/解决Hexo置顶问题/" target="_blank" rel="noopener">这篇文章</a>，安装插件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm <span class="keyword">uninstall</span> hexo-generator-<span class="keyword">index</span> <span class="comment">--save</span></span><br><span class="line">$ npm <span class="keyword">install</span> hexo-generator-<span class="keyword">index</span>-pin-top <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>之后再需要置顶文章的<code>Front-matter</code>中加上<code>top: true</code>属性即可，同时添加多个置顶按照时间顺序排序。</p><h4 id="NexT自定义首页展示文章内容"><a href="#NexT自定义首页展示文章内容" class="headerlink" title="NexT自定义首页展示文章内容"></a>NexT自定义首页展示文章内容</h4><p>之前遇到的一个需求，例如我的博客中存在<code>随笔</code>分类，而我希望我的首页只展现我的技术类文章。<a href="http://forwardkth.github.io/2016/05/08/next-theme-post-visibility/" target="_blank" rel="noopener">这篇文章</a>解决了这个问题，具体来说就是修改<code>layout</code>文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> YourBlogDir/themes/YourCurrentTheme/layout</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> open index.swig</span></span><br></pre></td></tr></table></figure><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> '_layout.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">import</span> '_macro/post.swig' <span class="keyword">as</span> post_template %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">import</span> '_macro/sidebar.swig' <span class="keyword">as</span> sidebar_template %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"></span><span class="template-variable">&#123;&#123; config.title &#125;&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.index_with_subtitle and config.subtitle %&#125;</span><span class="xml"> - </span><span class="template-variable">&#123;&#123;config.subtitle &#125;&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_class %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> is_home() %&#125;</span><span class="xml">page-home</span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> -%&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> content %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"posts"</span> <span class="attr">class</span>=<span class="string">"posts-expand"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> post <span class="keyword">in</span> page.posts %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> post.visible !== 'hide' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="template-variable">&#123;&#123; post_template.render(post, true) &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> '_partials/pagination.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> sidebar %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-variable">&#123;&#123; sidebar_template.render(false) &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>直接复制即可，主要就是添加了一个判断：如果文章中的<code>Front-matter</code>包含一个<code>visible</code>属性切属性为<code>hide</code>，那么首页就不进行展示。之后只要在<code>随笔</code>类的文章中添加属性即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">visible:</span> <span class="string">hide</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">随笔</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="更换个人域名"><a href="#更换个人域名" class="headerlink" title="更换个人域名"></a>更换个人域名</h2><p>如果想进一步<del>装逼</del>优化，那么可以为你的<code>github.io</code>包一个更具个性的域名，域名可以在<a href="https://wanwang.aliyun.com" target="_blank" rel="noopener">阿里万网</a>上买，经常有活动，便宜的一年也就10多块钱。</p><p>当你选好了一个域名之后需要对其进行解析，添加解析记录：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">记录类型: A // 指向一个IPV4地址</span></span><br><span class="line"><span class="section">主机记录: @ + www // @表空，再配置一个www的，不管你是输入www.xuhaoran.top还是xuhaoran.top都可以直接进入博客</span></span><br><span class="line"><span class="section">解析线路: 默认 </span></span><br><span class="line"><span class="section">记录值: 添加你的github.io的IP，可以终端ping一下就知道了，例如我的是151.101.1.147</span></span><br><span class="line"><span class="section">TTL值: 默认10分钟</span></span><br></pre></td></tr></table></figure><p>配置好域名解析之后进入<code>Github</code>的仓库，<code>Setting</code> —&gt; <code>Options</code> —&gt; <code>GitHub Pages</code> —&gt; <code>Custom domain</code>中设置好你申请的新域名。</p><p><img src="/assets/ArticleImg/custom domain.png" alt="custom domain"></p><p>最后新建一个<code>CNAME</code>文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> YourBlogDir/themes/YourCurrentTheme/<span class="built_in">source</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch CNAME</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim CNAME</span></span><br></pre></td></tr></table></figure><p>填写你的新域名在其中，<code>:wq</code>保存离开，这样就可以让你每次编译之后都可以直接使用新域名了。请愉快地访问你的新博客地址吧。</p><h2 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h2><p>备份博客思路参考<a href="https://wmaqingbo.github.io/blog/2017/07/05/备份Hexo源文件到Github/" target="_blank" rel="noopener">这篇文章</a>。这里按照我的理解说一下：</p><p><img src="/assets/ArticleImg/hexo-backup.png" alt="github hexo"></p><p>总体来说就是使用<code>git branch</code>来代替<code>静态页面仓库+源码仓库</code>的组合，新建一个分支并设为主分支，用来保存源码，<code>master</code>分支依然用来保存静态页面，这样做的好处是你日常的<code>hexo g -d</code>命令不受到影响，而当你面临着迁移博客的时候直接拉取你的<code>git</code>就可以了，任何修改直接提交，非常方便且简洁。</p><p>按照上面新建博客的步骤，我们已经有了一个可以部署到<code>Github</code>的博客了，现在直接对这个博客进行备份，直接简单粗暴的方法：</p><ul><li>在<code>Github</code>新建仓库，名字随意</li><li><code>clone</code>新仓库到本地，新建分支<code>hexo</code>并切换到该分支</li><li>在<code>Github</code>上设置<code>hexo</code>分支为主分支</li><li>复制本地blog文件到本地仓库，并提交代码到<code>hexo</code>分支</li><li>删除<code>Github</code>上的<code>xuhaoran.github.io</code>仓库，并将新仓库<code>Rename</code>为<code>xuhaoran.github.io</code></li></ul><p>这样其他配置不需要修改，强行把仓库迁移了<del>[手动微笑]</del>，以后如果切换电脑就可以直接拉取代码了~</p><p><em>这是这个博客的第二篇文章，中间断断续续地写了半个月，实在是汗颜，这两篇都是基础类的，之后会写一些iOS技术类博客，希望能给你帮助。如若有任何纰漏可以直接发邮件给我，还请见谅。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;这是迁移博客后的第二篇，其实我很懒，并不喜欢写博客这种吃力不讨好的活儿，看的人也未必多，但是每次写完一篇博客之后的&lt;del&gt;短暂的&lt;/del&gt;成就感以及写的这个过程中这种强制性的学习过程是很令人受用的。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;既然觉得在这个博客写下去，那么就总要找点内容，这次就来写一下这个小博客的搭建过程吧，其中绝大多数都是参照的网上资料，写这篇就当做是整理归纳成自己的东西吧。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Blog" scheme="http://xuhaoranleo.top/tags/Blog/"/>
    
      <category term="Hexo" scheme="http://xuhaoranleo.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Terminal命令小结</title>
    <link href="http://xuhaoranleo.top/2017/11/22/Terminal%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"/>
    <id>http://xuhaoranleo.top/2017/11/22/Terminal命令小结/</id>
    <published>2017-11-22T05:56:34.000Z</published>
    <updated>2018-04-18T08:45:26.127Z</updated>
    
    <content type="html"><![CDATA[<p><em>作为迁移博客的第一篇文章，不知道要写些什么内容，最近几个月忙项目忙装修，几乎从未想起博客这件事，近来有种卸磨杀驴的失落感，自知能力决定待遇的道理，所以还是要不断加强自身能力，其最好的方式莫过于分享，博客就是其中优选。</em></p><p><em>上次迁移博客是从博客园到简书，这次是从简书到github，其实决定因素还是美观度，hexo给我更极客的感觉，虽然自己并不极客。整个搭建、配置主题的过程大概用了两三天时间，这个过程中接触到了很多新知识，近期的博客计划也就从其中总结出来。</em></p><a id="more"></a><h2 id="关于Command-Line"><a href="#关于Command-Line" class="headerlink" title="关于Command Line"></a>关于Command Line</h2><p>从入行至今，使用Terminal的次数并不多，现用现查是常态，平时开发中<code>Git</code>也是使用图形界面工具，所以对Terminal非常陌生，直到最近自己搭了一个VPN才真正意识到命令行的便捷，而搭建博客的过程中命令行更是不可缺少的工具。</p><blockquote><p> 你可以整天驾驶汽车而不用知道如何修理它们，但是如果你希望当一个维护员，你就需要知道事情是如何运作的。同样的事情也发生在了 Mac OS X 上；你可以一直使用 Mac 而不用知道如何修理它，但是如果你想对系统做一些维护或解决一些问题，那么你需要知道如何使用 command-line。 </p><p> —— 网摘自<strong>Renfei Song</strong>‘s Blog</p></blockquote><p>Mac上很多功能不提供图形界面，只能通过命令行来实现，例如说<code>ssh</code>，Windows下需要使用<code>XShell</code>之类的软件来操作，而*nix系统直接使用终端命令就可以直接链接：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh username<span class="variable">@hostname</span></span><br></pre></td></tr></table></figure><p>通过Terminal可以访问所有目录，包括<code>Finder</code>隐藏的目录，而<code>Finder</code>的隐藏文件功能也只能通过<code>Terminal</code>开关，当然在系统<code>10.12</code>中可以使用<code>Shift</code>+<code>Command</code>+<code>.</code>来快速开启与关闭：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ defaults <span class="built_in">write</span> com.apple.finder AppleShowAllFiles -<span class="built_in">boolean</span> <span class="literal">true</span> ; killall Finder </span><br><span class="line">$ defaults <span class="built_in">write</span> com.apple.finder AppleShowAllFiles -<span class="built_in">boolean</span> <span class="literal">false</span> ; killall Finder</span><br></pre></td></tr></table></figure><p>Terminal可以做界面图形App能做的绝大多数操作，因为界面图形App背后使用的就是Command Line，例如在你安装<code>Xcode</code>之后，你就可以通过命令行进行编译和打包操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -workspace YourWorkspaceName -scheme YourSchemeName -configuration Debug archive -archivePath YourArchivePath</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -exportArchive -archivePath YourArchivePath -exportPath YourExportPath -exportOptionsPlist ./ConfigPlistName.plist</span></span><br></pre></td></tr></table></figure><p>虽然学习Command Line需要一个记忆和熟练的过程，但其强大且广泛的功能带给我们的便利快捷要远大于其学习成本，所以说使用Terminal，学会Command Line是一个程序员必备的素质之一。</p><h2 id="关于man命令"><a href="#关于man命令" class="headerlink" title="关于man命令"></a>关于man命令</h2><p>Terminal里面成百上千条命令，每一条命令还有其具体的参数方法，谁也不能全都记住，那么怎么办？推荐学习Command Line的人们最先掌握的命令<code>man</code>。通过<code>man CommandName</code>来获取你想知道的命令的使用指南：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">man</span> xcodebuild</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">     xcodebuild -- build Xcode projects and workspaces</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">     xcodebuild <span class="comment">[-project name.xcodeproj]</span></span><br><span class="line">                <span class="comment">[<span class="comment">[-target targetname]</span> ... | -alltargets]</span></span><br><span class="line">                <span class="comment">[-configuration configurationname]</span></span><br><span class="line">                <span class="comment">[-sdk <span class="comment">[sdkfullpath | sdkname]</span>]</span> <span class="comment">[action ...]</span></span><br><span class="line">                <span class="comment">[buildsetting=value ...]</span> <span class="comment">[-userdefault=value ...]</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>包括命令的名称、参数意义、使用描述等等，足够你理解使用这个命令了，在浏览期间可以通过<code>Space</code>翻页、<code>↑</code>和<code>↓</code>来滚动、输入<code>/ SearchKeyword</code>来搜索，使用<code>Q</code>退出页面。如果你不清楚这个命令的名字，可以使用<code>man -K Keyword</code>来搜索，Terminal会询问你搜索的结果是否是你想要的。</p><h2 id="关于路径与文件命令"><a href="#关于路径与文件命令" class="headerlink" title="关于路径与文件命令"></a>关于路径与文件命令</h2><p>虽然平时使用Finder管理文件已经很方便了，但是某些时候使用Terminal来进行路径和文件的操作也会非常便捷。</p><h3 id="路径命令"><a href="#路径命令" class="headerlink" title="路径命令"></a>路径命令</h3><p>路径分为绝对路径和相对路径。</p><p>绝对路径总是以<code>/</code>开头，例如<code>/Users/xuhaoran/blog</code>。</p><p>相对路径是根据你的Terminal当前的路径位置有关，Terminal默认路径为<code>Home Folder</code>，就是<code>⌘</code>+<code>⇧</code>+<code>H</code>的Folder，相对路径可以使用<code>../</code>来表示上一级路径，使用<code>./</code>表示本级路径，通常可以省略，使用<code>~/</code>则表示你的<code>Home Folder</code>。</p><p>绝对路径的第一个<code>/</code>代表根目录，而<code>/Users/UserName</code>即是<code>HomeFolder</code>。</p><p>如何获取绝对路径？有两个方法：1、打开Terminal后，直接拖拽Folder或File进来；2、使用<code>pwd</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/Users/xuhaoran/blog</span><br></pre></td></tr></table></figure><p>跳转到指定路径使用<code>cd</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> DirectoryName</span></span><br></pre></td></tr></table></figure><p><code>cd -</code>命令可以后退目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/Desktop/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/Downloads/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> -</span></span><br><span class="line">/Users/xuhaoran/Desktop</span><br></pre></td></tr></table></figure><p>查看当前路径下的所有Folder和File使用<code>ls</code>命令，值得一提的是使用<code>Tab</code>可以进行匹配输入，注意Terminal大小写敏感。通常情况<code>ls</code>命令是不显示隐藏文件的，可以使用<code>ls -A</code>来显示所有隐藏文件，即<code>.Name</code>形式的文件：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -A</span><br><span class="line"><span class="selector-class">.CFUserTextEncoding</span><span class="selector-class">.gitignore_global</span>.vim</span><br><span class="line"><span class="selector-class">.DS_Store</span><span class="selector-class">.hgignore_global</span>.viminfo</span><br></pre></td></tr></table></figure><p><code>pwd</code>、<code>cd</code>、<code>ls</code>三条命令搭配使用可以完成绝大多数的路径查询跳转工作，至于这三个命令的其他参数可以使用<code>man</code>来自行查询。</p><p>而创建与删除路径使用<code>mkdir</code>与<code>rmdir</code>两个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir DirectoryName</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rmdir DirectoryName</span></span><br></pre></td></tr></table></figure><p>使用<code>mkdir</code>命令时，如果想创建多层目录的话可以添加参数<code>p</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p dir1/dir2/dir3</span></span><br></pre></td></tr></table></figure><h3 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h3><p>通过Command Line检视文件，可以使用命令<code>cat</code>将文件内容输出到Terminal中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat Desktop/</span></span><br><span class="line">cat: Desktop/: Is a directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat Hello.text</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>面对较长的文本直接输出到Terminal中显然并不合理，那么可以使用<code>less</code>命令，在<code>less</code>命令进入文件后按<code>V</code>进入vim编辑器。</p><p>如果想查看文件类型信息，特别是在文件扩展名丢失的情况下，可以使用<code>file</code>命令：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">file</span> unnamed</span><br><span class="line">unnamed: ASCII <span class="built_in">text</span></span><br></pre></td></tr></table></figure><p>可以使用<code>touch</code>命令创建文件和指定文件扩展名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch FileName.ExpandedName</span></span><br></pre></td></tr></table></figure><p>创建之后可以直接进入编辑器进行编辑，可以使用<code>vim</code>命令进去vim编辑器或者<code>nano</code>命令进入nano编辑器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim FileName.ExpandedName</span></span><br></pre></td></tr></table></figure><p>可以使用<code>open</code>命令打开一个文件或者使用Finder打开一个Folder，使用<code>open .</code>命令来打开当前的Folder：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> open .</span></span><br></pre></td></tr></table></figure><p>对于基本的复制剪切操作可以分别使用<code>cp</code> 、<code>mv</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 将Test/ 复制/移动到 Workspace/</span><br><span class="line"><span class="meta">$</span><span class="bash"> cp Test/ Workspace/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv Test/ Workspace/</span></span><br></pre></td></tr></table></figure><h2 id="关于权限命令"><a href="#关于权限命令" class="headerlink" title="关于权限命令"></a>关于权限命令</h2><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>查看当前目录下的文件权限可以使用<code>ls -alh</code>命令：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ls -alh</span><br><span class="line">total 8152</span><br><span class="line">/*</span><br><span class="line">    权限        拥有者 群组</span><br><span class="line">*/</span><br><span class="line">-rw-r--r--@ <span class="number"> 1 </span>xuhaoran  staff   104K<span class="number"> 11 </span>22 14:07 430DDC5092226B6C4F062BAEF2242B78.jpg</span><br><span class="line">drwxr-xr-x <span class="number"> 10 </span>xuhaoran  staff   320B<span class="number"> 11 </span><span class="number"> 2 </span>14:05 AlamofireDemo</span><br><span class="line">-rw-r--r--@ <span class="number"> 1 </span>xuhaoran  staff   956B<span class="number"> 10 </span>13 <span class="number"> 2016 </span>CertificateSigningRequest.certSigningRequest</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中权限部分详细的分为<code>d rwx rwx rwx</code>四部分。</p><p>第一部分中<code>d</code>表示为Directory，而<code>-</code>则表示File。</p><p>后面三部分分别表示“对所有者”、“对同组人”、“对其他人”的权限，<code>r</code>读取权限、<code>w</code>写入权限、<code>x</code>执行权限，<code>-</code>表示无权限。</p><p>以其中<code>AlamofireDemo</code>为例，表示为目录、所有者可读可写可执行、同组人可读可执行、其他人可读可执行。</p><p>而三部分的权限可使用数字表示，其中<code>r</code>权限为2²，<code>w</code>权限为2¹，<code>x</code>权限为2º，例如：<code>AlamofireDemo</code>目录的全校可以表示为<code>755</code>，而<code>cerSigningRequest</code>文件的权限为<code>644</code>。</p><p>权限是可以变更的，使用<code>chmod</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod -R 755 AlamofireDemo</span></span><br></pre></td></tr></table></figure><p>这是通常情况下的标准命令，为文件添加<code>rwxr-xr-x</code>权限，<code>-R</code>参数表示改变目录结构下所有子目录文件的权限而并非目录本身。<code>chmod 777 FileName</code>则是非常危险的命令，赋予了其他人与root相同的权限。</p><p><code>chmod</code>还有一种改变权限的形式，使用运算符<code>+</code>(增加)、<code>-</code>(去除)、<code>=</code>(覆盖设定)配合用户类型<code>u</code>(所有者)、<code>g</code>(同组人)、<code>o</code>(其他人)、<code>a</code>(全部)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod -R g+x AlamofireDemo/</span></span><br></pre></td></tr></table></figure><p>上面这条命令是为<code>AlamofireDemo</code>这个目录的同组人添加执行权限。</p><p>同样，拥有者和群组也是可以改变的，使用<code>chown</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chown UserName:GroupName FileName</span></span><br></pre></td></tr></table></figure><h3 id="root权限"><a href="#root权限" class="headerlink" title="root权限"></a>root权限</h3><p><code>sudo</code>命令的作用在于会用root账户权限来执行后面的命令，通常在执行一条命令提示<code>Permission denied</code>时使用。使用<code>sudo !!</code>再次执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat secret.doc</span></span><br><span class="line">Permission denied</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo !!</span></span><br><span class="line">Password: *</span><br></pre></td></tr></table></figure><p>如果执行多条需要root权限的命令，可以使用<code>sudo -s</code>获取root权限，注意<code>#</code>代替了<code>$</code>表示使用root权限操作，操作结束可以使用<code>Control</code>+<code>D</code>或者输入<code>exit</code>命令来退出环境：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xuhaoran$ sudo -s</span><br><span class="line"><span class="symbol">Password:</span></span><br><span class="line">bash<span class="number">-3.2</span><span class="meta"># exit</span></span><br></pre></td></tr></table></figure><h2 id="关于网络通信的命令"><a href="#关于网络通信的命令" class="headerlink" title="关于网络通信的命令"></a>关于网络通信的命令</h2><h3 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h3><p>在网络通信之前，最常用的操作就是<code>ping</code>命令，它会给网络主机发送一个回应请求，进而验证可否进行通信：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$<span class="built_in"> ping </span>panghu.cf</span><br><span class="line">PING panghu.cf (128.14.32.165): 56 data bytes</span><br><span class="line">64 bytes <span class="keyword">from</span> 128.14.32.165: <span class="attribute">icmp_seq</span>=0 <span class="attribute">ttl</span>=50 <span class="attribute">time</span>=168.334 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 128.14.32.165: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=50 <span class="attribute">time</span>=158.529 ms</span><br></pre></td></tr></table></figure><p>可使用<code>Control</code>+<code>C</code>停止发送请求。</p><h3 id="ssh命令"><a href="#ssh命令" class="headerlink" title="ssh命令"></a>ssh命令</h3><p><code>ssh</code>是一种远程登录和其他安全服务的协议，远程登录相比较于<code>telnet</code>和<code>rlogin</code>两种协议，有其特有的优势，例如加密传输、数据压缩等。</p><p>Mac的Terminal自带SSH，使用<code>ssh</code>就可以登录远程服务器：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh root<span class="variable">@panghu</span>.cf</span><br><span class="line">root<span class="variable">@panghu</span>.cf<span class="string">'s password: *</span></span><br></pre></td></tr></table></figure><p>之后就可以在远程服务器进行一些常规操作或者一些逗逼的命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -<span class="keyword">N</span> --<span class="keyword">no</span>-check-certificate http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/ToyoDAdoubi/doubi/master/ssr.<span class="keyword">sh</span> &amp;&amp; chmod +<span class="keyword">x</span> ssr.<span class="keyword">sh</span> &amp;&amp; bash ssr.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>网络通信命令还有很多，这里限于能力就不献丑了。</p><h2 id="关于其他系统命令"><a href="#关于其他系统命令" class="headerlink" title="关于其他系统命令"></a>关于其他系统命令</h2><p><code>bash</code>命令是用来执行一段脚本命令的命令，通常可以用来执行本地写好的脚本，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bash ssr.sh</span></span><br></pre></td></tr></table></figure><p><code>who</code>命令可以列出当前登录的所有用户，<code>who am i</code>显而易见是回答“我是谁？”的问题：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ who</span><br><span class="line">xuhaoran<span class="built_in"> console </span> Nov 20 17:06 </span><br><span class="line">xuhaoran ttys001  Nov 22 13:52 </span><br><span class="line">xuhaoran ttys002  Nov 23 14:52 </span><br><span class="line">$ who am i</span><br><span class="line">xuhaoran ttys002  Nov 23 14:52</span><br></pre></td></tr></table></figure><p><code>console</code>是电脑的底层控制台，伴随着电脑开机而启动；<code>ttys</code>（Teletypewriter的缩写）则是Terminal的类型名称，随着Terminal数量增加而增加计数。使用<code>Command</code>+<code>N</code>来新建Terminal。</p><p>至于<code>Console</code>、<code>Terminal</code>、<code>tty</code>和<code>Shell</code>的关系这里就不叙述了。</p><p>使用<code>ps</code>命令来查看进程状态，可以确定哪些进程僵死或过多占用资源等。通常使用<code>ps aux</code>来查看具体进程：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux</span><br><span class="line">USER               PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND</span><br><span class="line">xuhaoran           355   3.0  3.0  7056284 249392   ??  S    一05下午  57:40.33 /Applications/WeChat.app/Contents/MacOS/WeChat -psn_0_57358</span><br><span class="line">root                96   0.3  0.1  4346796   8364   ??  Ss   一05下午   3:00.86 /usr/libexec/opendirectoryd</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p><code>PID</code>表示进程的id，<code>%CPU</code>、<code>%MEM</code>分别表示进程占用CPU和内存的比重，<code>VSZ</code>表示使用掉的虚拟内存(KB)，<code>RSS</code>表示占用的固定内存(KB)，<code>TT</code>表示在哪个Terminal上执行，<code>STAT</code>表示该进程目前的状态。</p><p>关于<code>STAT</code>的状态码：</p><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:left"><code>R</code></td><td style="text-align:center">正在运行</td></tr><tr><td style="text-align:left"><code>S</code></td><td style="text-align:center">休眠</td></tr><tr><td style="text-align:left"><code>T</code></td><td style="text-align:center">停止</td></tr><tr><td style="text-align:left"><code>Z</code></td><td style="text-align:center">僵死</td></tr><tr><td style="text-align:left"><code>&lt;</code></td><td style="text-align:center">高优先级</td></tr><tr><td style="text-align:left"><code>N</code></td><td style="text-align:center">低优先级</td></tr><tr><td style="text-align:left"><code>L</code></td><td style="text-align:center">锁定</td></tr><tr><td style="text-align:left"><code>s</code></td><td style="text-align:center">存在子进程</td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:center">后台进程组</td></tr></tbody></table><p>查询到进程之后可以使用<code>kill</code>命令用来终止进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -SignalNumber PID</span></span><br></pre></td></tr></table></figure><p>至于<code>SignalNumber</code>可以通过命令<code>kill l</code>获取：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kill -l</span><br><span class="line"> <span class="number">1</span>) SIGHUP       <span class="number">2</span>) SIGINT       <span class="number">3</span>) SIGQUIT      <span class="number">4</span>) SIGILL</span><br><span class="line"> <span class="number">5</span>) SIGTRAP      <span class="number">6</span>) SIGABRT      <span class="number">7</span>) SIGEMT       <span class="number">8</span>) SIGFPE</span><br><span class="line"> <span class="number">9</span>) SIGKILL     <span class="number">10</span>) SIGBUS      <span class="number">11</span>) SIGSEGV     <span class="number">12</span>) SIGSYS</span><br><span class="line"><span class="number">13</span>) SIGPIPE     <span class="number">14</span>) SIGALRM     <span class="number">15</span>) SIGTERM     <span class="number">16</span>) SIGURG</span><br><span class="line"><span class="number">17</span>) SIGSTOP     <span class="number">18</span>) SIGTSTP     <span class="number">19</span>) SIGCONT     <span class="number">20</span>) SIGCHLD</span><br><span class="line"><span class="number">21</span>) SIGTTIN     <span class="number">22</span>) SIGTTOU     <span class="number">23</span>) SIGIO       <span class="number">24</span>) SIGXCPU</span><br><span class="line"><span class="number">25</span>) SIGXFSZ     <span class="number">26</span>) SIGVTALRM   <span class="number">27</span>) SIGPROF     <span class="number">28</span>) SIGWINCH</span><br><span class="line"><span class="number">29</span>) SIGINFO     <span class="number">30</span>) SIGUSR1     <span class="number">31</span>) SIGUSR2</span><br></pre></td></tr></table></figure><p>其中常用的为9(SIGKILL)，对付大多数程序可以<code>kill -9 PID</code>直接干掉。</p><p>其他常用的系统命令有查看时间的命令<code>date</code>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br><span class="line"><span class="number">2017</span>年<span class="number">11</span>月<span class="number">23</span>日 星期四 <span class="number">16</span>时<span class="number">47</span>分<span class="number">40</span>秒 CST</span><br></pre></td></tr></table></figure><p>查看日历的命令<code>cal</code>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cal</span><br><span class="line">      十一月 <span class="number">2017</span>        </span><br><span class="line">日 一 二 三 四 五 六  </span><br><span class="line">          <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  </span><br><span class="line"> <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>  </span><br><span class="line"><span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span>  </span><br><span class="line"><span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">25</span>  </span><br><span class="line"><span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">29</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p><code>cal</code>命令后面可接年份，例如<code>cal 2017</code>，也可以接月份+年份，例如<code>cal 8 2018</code>表示展现2018年8月的日历。</p><h2 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h2><h3 id="alias与unalias命令"><a href="#alias与unalias命令" class="headerlink" title="alias与unalias命令"></a>alias与unalias命令</h3><p>对于常用的命令可以使用<code>alias</code>为其添加别名，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">alias</span> del=<span class="string">"rm -rf"</span></span></span><br></pre></td></tr></table></figure><p>删除别名可以使用<code>unalias</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unalias</span> del</span></span><br></pre></td></tr></table></figure><h3 id="退出及清屏命令"><a href="#退出及清屏命令" class="headerlink" title="退出及清屏命令"></a>退出及清屏命令</h3><p>使用<code>control</code>+<code>C</code> 可以终止持续进行的命令，例如<code>ping</code>命令。</p><p>使用<code>control</code>+<code>D</code>或者<code>exit</code>命令可以结束当前状态，例如结束<code>ssh</code>的远程链接。</p><p>使用<code>control</code>+<code>L</code>或者<code>clear</code>命令可以清屏，与<code>reset</code>命令不同的是，<code>clear</code>可以滚动查看之前的内容，而<code>reset</code>则是完全清除内容。</p><h3 id="光标操作"><a href="#光标操作" class="headerlink" title="光标操作"></a>光标操作</h3><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>control</code>+<code>A</code></td><td style="text-align:right">移动光标至行首</td></tr><tr><td style="text-align:center"><code>control</code>+<code>E</code></td><td style="text-align:right">移动光标至行尾</td></tr><tr><td style="text-align:center"><code>control</code>+<code>U</code></td><td style="text-align:right">删除整行命令</td></tr><tr><td style="text-align:center"><code>control</code>+<code>K</code></td><td style="text-align:right">删除光标后面的内容</td></tr><tr><td style="text-align:center"><code>option</code>+<code>←</code>、<code>→</code></td><td style="text-align:right">按词组移动光标</td></tr></tbody></table><h3 id="快速操作"><a href="#快速操作" class="headerlink" title="快速操作"></a>快速操作</h3><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>!!</code></td><td style="text-align:right">执行上一条命令</td></tr><tr><td style="text-align:center"><code>!</code></td><td style="text-align:right">重复命令，例如<code>$ ! -3</code>执行前三条命令、<code>$ !pod</code>重复最近一次的<code>pod</code>命令等</td></tr><tr><td style="text-align:center">`</td><td style="text-align:right">`</td><td>将左侧命令结果扔给右侧命令，例如`$ ps aux</td><td>pbcopy`将进程信息保存的剪贴板</td></tr><tr><td style="text-align:center"><code>&gt;</code></td><td style="text-align:right">将左侧命令结果保存进右侧文件，例如<code>$ pbpaste &gt; out.txt</code>将剪贴板内容保存到文件</td></tr><tr><td style="text-align:center"><code>&amp;&amp;</code></td><td style="text-align:right">等待前一条命令执行成功之后执行后面命令，例如<code>$ chmod +x ssr.sh &amp;&amp; bash ssr.sh</code></td></tr><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:right">多条命令同时执行，例如<code>$ chmod +x ssr.sh &amp; chmod +x other.sh</code></td></tr><tr><td style="text-align:center"><code>;</code></td><td style="text-align:right">不管前面命令成功与否都继续执行后面命令，例如<code>$ chmod +x ssr.sh ; cp ssr.sh ~/Desktop/</code></td></tr></tbody></table><p>使用<code>history</code>命令可以查询执行命令的历史记录<code>history PageCnt</code>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ history <span class="number">10</span></span><br><span class="line">  <span class="number">543</span>  kill l</span><br><span class="line">  <span class="number">544</span>  kill -l</span><br><span class="line">  <span class="number">545</span>  date</span><br><span class="line">  <span class="number">546</span>  cal</span><br><span class="line">  <span class="number">547</span>  ssh root@panghu.cf</span><br><span class="line">  <span class="number">548</span>  ls</span><br><span class="line">  <span class="number">549</span>  ping panghu.cf</span><br><span class="line">  <span class="number">550</span>  ftp panghu.cf</span><br><span class="line">  <span class="number">551</span>  yum</span><br><span class="line">  <span class="number">552</span>  ls</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>连续写了两天时间，期间不断的去查询和完善内容，感觉这个过程又收获了很多知识。</p><p>Terminal的强大只有真正融入进去才能感受得到，以上这些都只是本人在工作中遇到的最基本的内容，说成冰山一角毫不为过，所以日后遇到新的内容还会继续进行补充更新。</p><p>最后，很多命令下的参数都有不同的用法，当遇到问题了请熟练地使用<code>man</code>命令，希望对您有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;作为迁移博客的第一篇文章，不知道要写些什么内容，最近几个月忙项目忙装修，几乎从未想起博客这件事，近来有种卸磨杀驴的失落感，自知能力决定待遇的道理，所以还是要不断加强自身能力，其最好的方式莫过于分享，博客就是其中优选。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;上次迁移博客是从博客园到简书，这次是从简书到github，其实决定因素还是美观度，hexo给我更极客的感觉，虽然自己并不极客。整个搭建、配置主题的过程大概用了两三天时间，这个过程中接触到了很多新知识，近期的博客计划也就从其中总结出来。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Terminal Command Line" scheme="http://xuhaoranleo.top/tags/Terminal-Command-Line/"/>
    
  </entry>
  
</feed>
